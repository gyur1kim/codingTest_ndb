> *연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘*
> 
> *큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법*
>

## 다이나믹 프로그래밍의 기본적인 아이디어

**[점화식]**

- **인접**한 항들 사이의 **관계식**
- 점화식을 이용해 현재의 항을 이전의 항에 대한 식으로 표현할 수 있음

**[DP를 사용할 수 있는 조건]**

- 큰 문제를 작은 문제로 나눌 수 있다
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

## 2가지 방식

**[탑다운(하향식)]**

- 재귀함수를 이용하여 DP 소스 코드를 작성하는 방법
- 큰 문제를 해결하기 위해 작은 문제를 호출한다
- 결과 저장용 리스트 = `메모이제이션`

**[바텀업(상향식)]**

- 단순 반복문을 이용하여 소스코드를 작성하는 방법
- 작은 문제부터 차근차근 답을 도출한다
- 결과 저장용 리스트 = `DP테이블`

## 메모이제이션 기법

- DP를 구현하는 방법 중 한 종류
- 한 번 구한 결과를 **메모리 공간**에 메모해두고 같은 식을 다시 호출하면 메모한 **결과**를 그대로 **가져오는 기법**
- 캐싱(Chacing)이라고도 함

## 문제를 푸는 단계

1. DP 유형임을 파악하기
   - 완전 탐색 알고리즘으로 접근했을 때 시간이 오래 걸리면? DP 의심해보기
   - 해결하고자 하는 부분 문제들의 중복 여부를 확인하자
2. 탑다운, 바텀업 방식으로 구현해보기
   - 재귀로 코드를 작성한 뒤 작은 문제에서 구한 답을 큰 문제에서도 그대로 사용할 수 있다면, **메모이제이션**을 적용하여 코드를 개선하기
   - 재귀는 recursion depth와 관련된 에러가 날 수 있기 때문에 바텀업 방식을 권장